#!/usr/bin/env python3
# coding: utf-8

import os
import sys
import argparse
from pathlib import Path

try:
  import pandas as pd
except ModuleNotFoundError:
  sys.exit("Module 'pandas' not installed. Exiting.")

try:
  import numpy as np
except ModuleNotFoundError:
  sys.exit("Module 'numpy' not installed. Exiting.")


def md(error):
  # md = mean(error)
  return np.mean(error)


def mad(error):
  # mad = mean( abs( error - mean(error) ) )
  return np.mean(np.absolute(error - np.mean(error)))


def mae(error):
  # mae = mean( abs( error ) )
  return np.mean(np.absolute(error))


def std(error):
  # std = sqrt( mean( abs( error - mean(error) )**2 ) )
  return np.std(error, dtype=np.float64)


def rmsd(error):
  return np.sqrt(np.mean(np.square(error)))


def getFileList():
  filelist = []
  for file in sorted(Path(".").rglob('*data')):
    filelist.append(file)

  if len(filelist) == 0:
    sys.exit("No '*data' files found.")

  return filelist


def init_argparser():
  parser = argparse.ArgumentParser(
      description='Q-CHEM JOB INFO\nSearch recursively for all *d4*.out files and get general info.')
  parser.add_argument("-v", '--verbose', nargs='?', const=0, type=int,
                      help="Print more. Number of rows optional. 0 prints everything")
  parser.add_argument("-s", "--save", nargs='?', const="fit_params.csv",
                      type=str, help="Save output. Name is optional. Defaults to 'fit_params.csv'.")
  parser.add_argument("--sort", nargs='?', const="func",
                      type=str, help="Sorting table. Defaults to 'func'")
  
  return parser.parse_args()


def main():
  args = init_argparser()

  data = []
  flist = getFileList()
  for i, file in enumerate(flist):
    out_file = Path(f"{file.parent}/{file.name[:-4]}d4_eeq_atm.out")
    data_file = file

    # check of files are present
    if not out_file.is_file():
      print(f"WARNING!!! File {out_file} not found. Skipping...")
      continue

    if not data_file.is_file():
      print(f"WARNING!!! File {data_file} not found. Skipping...")
      continue
    
    s = out_file.name.strip("").split("_")

    # get omega
    if s[1].isdigit():
      omega = s[1]
    else:
      omega = 0
    
    # functional name
    if "orca" in s:
      func = f"{s[0]}-orca"
    elif "tm" in s:
      func = f"{s[0]}-tm"
    else:
      func = s[0]

    # parameters
    with open(out_file) as f:
      paramblock = False
      start_paramblock = False

      for line in f:
        if line.startswith("Parameters used in this run:"):
          start_paramblock = True
          continue

        if start_paramblock:
          line = line.strip()
          if line.startswith("1"):
            s8_start = line.split()[-1]
          if line.startswith("2"):
            a1_start = line.split()[-1]
          if line.startswith("3"):
            a2_start = line.split()[-1]
            start_paramblock = False

        if line.startswith("Optimizied parameters"):
          paramblock = True
          continue

        if paramblock:
          line = line.strip()
          if line.startswith("1"):
            s8 = line.split()[-1]
          if line.startswith("2"):
            a1 = line.split()[-1]
          if line.startswith("3"):
            a2 = line.split()[-1]


    # stats
    with open(data_file) as d:
      stat_data = np.genfromtxt(d)
      smpl = stat_data[:, 0] - stat_data[:, 1]

      md_ = md(smpl)
      mae_ = mae(smpl)
      rmsd_ = rmsd(smpl)
      std_ = std(smpl)


    # check if fit converged
    if not paramblock:
      print(f"WARNING! No parameters found in {out_file}.")
      data.append([func, omega, s8_start, "NaN", a1_start, "NaN", a2_start, "NaN", md_, mae_, rmsd_, std_])
    else:
      data.append([func, omega, s8_start, s8, a1_start, a1, a2_start, a2, md_, mae_, rmsd_, std_])

    # print progress
    progress(i, len(flist))


  # printing and saving
  cols = ["func", "omega", "s8-start", "s8-final", "a1-start", "a1-final",\
   "a2-start", "a2-final", "MD", "MAD", "RMSD", "SD"]
  df = pd.DataFrame(columns=cols, data=data)


  # only get lowest MAD for every omega
  if args.best:
    df = df.loc[df.groupby("omega")["MAD"].idxmin()]


  # sort by column
  if args.sort:
    df = df.sort_values(by=args.sort)


  # print to console
  if args.verbose is not None:
    if args.verbose == 0:
      pd.set_option('display.max_rows', df.shape[0] + 1)
      print(df)
    else:
      print(df.head(args.verbose))
  else:
    print(df.to_string(index=False))


  # save
  if args.save:
    save_loc = os.path.join(os.path.realpath("."), args.save)
    df.to_csv(save_loc, index=False)
    print("\nSaved data to {}.".format(save_loc))



def progress(count, total, status=''):
  bar_len = 60
  filled_len = int(round(bar_len * count / float(total)))

  percents = round(100.0 * count / float(total), 1)
  bar = '=' * filled_len + '-' * (bar_len - filled_len)

  sys.stdout.write('[%s] %s%s %s\r' % (bar, percents, '%', status))
  sys.stdout.flush()


if __name__ == '__main__':
  main()
